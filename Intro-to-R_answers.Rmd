---
title: "Intro-to-R w/answers"
output: html_document
date: "2023-08-07"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
##### 01 IntroR and RStudio

```{r}
getwd()
```

```{r}
# Intro to R Lesson
# Feb 16th, 2016

# Interacting with R

## I am adding 3 and 5. R is fun!
3+5
```

##### Exercise
Try running only 3 + in the console. Find a way to bring back the command prompt > in the console.

Ans: escape key

```{r}
x <- 3
y <- 5
```

```{r}
number <- x + y
```
##### Exercise
1. Try changing the value of the variable x to 5. What happens to number?
2. Now try changing the value of variable y to contain the value 10. What do you need to do, to update the variable number?

```{r}
x <- 5
y <- 10
number

# you need to update number
number <- x + y
number
```

##### IntroR syntax and data structures

```{r}
# Create a numeric vector and store the vector as a variable called 'glengths'
glengths <- c(4.6, 3000, 50000)
glengths
```
```{r}
# Create a character vector and store the vector as a variable called 'species'
species <- c("ecoli", "human", "corn")
species
```

##### Exercise
Try to create a vector of numeric and character values by combining the two vectors that we just created (glengths and species). Assign this combined vector to a new variable called combined. Hint: you will need to use the combine c() function to do this. Print the combined vector in the console, what looks different compared to the original vectors?

```{r}
combined <- c(glengths, species)
combined
```

Ans: the numeric values have changed to character values.


```{r}
# Create a character vector and store the vector as a variable called 'expression'
expression <- c("low", "high", "medium", "high", "low", "medium", "high")
expression
```

```{r}
# Turn 'expression' vector into a factor
expression <- factor(expression)
expression
```
##### Exercises

Let’s say that in our experimental analyses, we are working with three different sets of cells: normal, cells knocked out for geneA (a very exciting gene), and cells overexpressing geneA. We have three replicates for each celltype.

1. Create a vector named samplegroup with nine elements: 3 control (“CTL”) values, 3 knock-out (“KO”) values, and 3 over-expressing (“OE”) values.

2. Turn samplegroup into a factor data structure.

```{r}
samplegroup = c("CTL","CTL","CTL","KO","KO","KO","OE","OE","OE")

#OR

samplegroup = c(rep("CTL",3),rep("KO",3),rep("OE",3))

factor(samplegroup)
```


```{r}
# Create a data frame and store it as a variable called 'df'
df <- data.frame(species, glengths)
df
```
##### Exercise
Create a data frame called favorite_books with the following vectors as columns:

```{r}
titles <- c("Catch-22", "Pride and Prejudice", "Nineteen Eighty Four")
pages <- c(453, 432, 328)
```
```{r}
data.frame(titles,pages)
```

Lists
```{r}
list1 <- list(species, df, number)
list1
```

##### Exercise
Create a list called list2 containing species, glengths, and number.
```{r}
list2 <- list(species, glengths, number)
```
##### 03 IntroR functions and arguments 
```{r}
glengths <- c(glengths, 90) # adding at the end 
glengths
glengths <- c(30, glengths) # adding at the beginning
glengths
```
```{r}
sqrt(81)
```
```{r}
sqrt(glengths)
```
```{r}
round(3.14159)
```
```{r}
?round
```
```{r}
args(round)
```
```{r}
example("round")
```
```{r}
round(3.14159, digits=2)
```

##### Exercise
1. Let’s use base R function to calculate mean value of the glengths vector. You might need to search online to find what function can perform this task.
2. Create a new vector test <- c(1, NA, 2, 3, NA, 4). Use the same base R function from exercise 1 (with addition of proper argument), and calculate mean value of the test vector. The output should be 2.5. > NOTE: In R, missing values are represented by the symbol NA (not available). It’s a way to make sure that users know they have missing data, and make a conscious decision on how to deal with it. There are ways to ignore NA during statistical calculation, or to remove NA from the vector. If you want more information related to missing data or NA you can go to this page (please note that there are many advanced concepts on that page that have not been covered in class).
3. Another commonly used base function is sort(). Use this function to sort the glengths vector in descending order.

1.
```{r}
mean(glengths)
```
2. 
```{r}
test <- c(1, NA, 2, 3, NA, 4)
mean(test, na.rm = TRUE)
```
3.
```{r}
sort(glengths, decreasing = TRUE)
```



```{r}
square_it <- function(x) {
    square <- x * x
    return(square)
}
```
```{r}
square_it(5)
```
##### Exercise
Write a function called multiply_it, which takes two inputs: a numeric value x, and a numeric value y. The function will return the product of these two numeric values, which is x * y. For example, multiply_it(x=4, y=6) will return output 24.

```{r}
multiply_it <- function(x,y) {
    product <- x * y
    return(product)
}
```
```{r}
multiply_it(x=4, y=6) 
```
##### 04 IntroR_packages

```{r}
sessionInfo() #Print version information about R, the OS and attached or loaded packages

# OR

search() #Gives a list of attached packages
```
Set eval = TRUE if you haven't installed ggplot2 yet
```{r, eval=FALSE}
install.packages("ggplot2")
```
Install BiocManager
```{r}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install(version = "3.17")
```
Now you can use BiocManager::install to install other packages

```{r, eval=FALSE}
# DO NOT RUN THIS!
BiocManager::install("ggplot2")

```

Installing packages from source:
```{r, eval=FALSE}
# DO NOT RUN THIS!
install.packages("~/Downloads/ggplot2_1.0.1.tar.gz", type="source", repos=NULL)
```

Loading libraries

```{r}
library(ggplot2)
```

##### Exercise

The ggplot2 package is part of the tidyverse suite of integrated packages which was designed to work together to make common data science operations more user-friendly. We will be using the tidyverse suite in later lessons, and so let’s install it. NOTE: This suite of packages is only available in CRAN.

```{r}
BiocManager::install("tidyverse")
```

##### 05 introR-data-wrangling

```{r}
age <- c(15, 22, 45, 52, 73, 81)
age
age[5]
```
```{r}
age[-5]
```

```{r}
age[c(3,5,6)]   ## nested

# OR

## create a vector first then select
idx <- c(3,5,6) # create vector of the elements of interest
age[idx]
```
```{r}
age[1:4]
```

##### Exercises

1. Create a vector called alphabets with the following letters, C, D, X, L, F.
2. Use the associated indices along with [ ] to do the following:
      a. only display C, D and F
      b. display all except X
      c. display the letters in the opposite order (F, L, X, D, C)
      
1.
```{r}
alphabets = c("C","D","X","L","F")
```
2. 
```{r}
alphabets[c(1,2,5)]

alphabets[c(1,2,4,5)]

rev(alphabets)
```


```{r}
age > 50
```

```{r}
age > 50 | age < 18

age

age[age > 50 | age < 18]  ## nested

# OR

## create a vector first then select
idx <- age > 50 | age < 18
age[idx]
```

```{r}
which(age > 50 | age < 18)

age[which(age > 50 | age < 18)]  ## nested

# OR

## create a vector first then select
idx_num <- which(age > 50 | age < 18)
age[idx_num]
```
```{r}
expression[expression == "high"]    ## This will only return those elements in the factor equal to "high"
```
##### Exercise

Extract only those elements in samplegroup that are not KO (nesting the logical operation is optional).

```{r}
samplegroup
samplegroup[c(1:3,7:9)]
```


```{r}
expression

str(expression)
```
```{r}
expression <- factor(expression, levels=c("low", "medium", "high"))     # you can re-factor a factor 

str(expression)
```
##### Exercise

Use the samplegroup factor we created in a previous lesson, and relevel it such that KO is the first level followed by CTL and OE.

```{r}
samplegroup <- factor(samplegroup)
samplegroup
factor(samplegroup,levels = c("KO","CTL","OE"))
```


##### 06 Reading and data inspection

```{r}
metadata <- read.csv(file="data/mouse_exp_design.csv")

```


##### Exercise

1. Read "project-summary.txt" in to R using read.table() with the approriate arguments and store it as the variable proj_summary. To figure out the appropriate arguments to use with read.table(), keep the following in mind:
all the columns in the input text file have column name/headers
you want the first column of the text file to be used as row names (hint: look up the input for the row.names = argument in read.table())
2. Display the contents of proj_summary in your console

```{r}
proj_summary <- read.table("data/project-summary.txt",row.names = 1,header = TRUE)
# type proj_summary into console
```

```{r}
head(metadata)
str(metadata)
dim(metadata)
nrow(metadata)
ncol(metadata)
```
##### Exercise 2

Use the class() function on glengths and metadata, how does the output differ between the two?
```{r}
class(glengths)
class(metadata)
```
Use the summary() function on the proj_summary dataframe, what is the median “Intronic_Rate?

```{r}
summary(proj_summary)
```

Ans: Median :0.06630

How long is the samplegroup factor?

Ans: 3

What are the dimensions of the proj_summary dataframe?

```{r}
dim(proj_summary)
```
When you use the rownames() function on metadata, what is the data structure of the output?
```{r}
str(rownames(metadata))
```
[Optional] How many elements in (how long is) the output of colnames(proj_summary)? Don’t count, but use another function to determine this.

```{r}
length(colnames(proj_summary))
```


##### 07 introR-data-wrangling2

```{r}
# Extract value 'Wt'
metadata[1, 1]
```
```{r}
# Extract third row
metadata[3, ] 
```
```{r}
# Extract third column
metadata[ , 3]  
```
```{r}
# Extract third column as a data frame
metadata[ , 3, drop = FALSE] 
```
```{r}
# Dataframe containing first two columns
metadata[ , 1:2] 
```
```{r}
# Data frame containing first, third and sixth rows
metadata[c(1,3,6), ] 
```
```{r}
# Extract the celltype column for the first three samples
metadata[c("sample1", "sample2", "sample3") , "celltype"] 
```

```{r}
# Check column names of metadata data frame
colnames(metadata)

# Check row names of metadata data frame
rownames(metadata)
```
```{r}
# Extract the genotype column
metadata$genotype 
```
```{r}
# Extract the first five values/elements of the genotype column
metadata$genotype[1:5]
```

##### Exercises

Return a data frame with only the genotype and replicate column values for sample2 and sample8.

```{r}
metadata[c(2,8),c("genotype","replicate")]
```

Return the fourth and ninth values of the replicate column.
```{r}
metadata$replicate[c(4,9)]
```
Extract the replicate column as a data frame.

```{r}
metadata[,"replicate",drop = FALSE]
```


```{r}
metadata$celltype == "typeA"
```
```{r}
logical_idx <- metadata$celltype == "typeA"
```

```{r}
metadata[logical_idx, ]
```
```{r}
idx <- which(metadata$celltype == "typeA")
```

```{r}
metadata[idx, ]
```

```{r}
idx <- which(metadata$replicate > 1)
    
metadata[idx, ]

```

```{r}
sub_meta <- metadata[which(metadata$replicate > 1), ]
```

##### Exercise

Subset the metadata dataframe to return only the rows of data with a genotype of KO.

```{r}
metadata[which(metadata$genotype == "KO"), ]
```

Lists

```{r}
list1[[2]]
```

```{r}
comp2 <- list1[[2]]
class(comp2)
```

```{r}
list1[[1]]
```
```{r}
list1[[1]][1]
```
##### Exercises

Create a list named random with the following components: metadata, age, list1, samplegroup, and number.
```{r}
random <- list(metadata, age, list1, samplegroup, number)
```
Extract the samplegroup component.

```{r}
random[[4]]
```

```{r}
names(list1)

# Name components of the list
names(list1) <- c("species", "df", "number")
    
names(list1)
```

```{r}
# Extract 'df' component
list1$df
```
##### Exercise

Let’s practice combining ways to extract data from the data structures we have covered so far:

Set names for the random list you created in the last exercise.
```{r}
names(random) <- c("metadata","age","list1","samplegroup","number")
```
Extract the age component using the $ notation

```{r}
random$age
```
##### 08 identifying matching elements

```{r}
rpkm_data <- read.csv("data/counts.rpkm.csv")
```
```{r}
head(rpkm_data)
ncol(rpkm_data)
nrow(metadata)
```
# The %in% operator

```{r}
A <- c(1,3,5,7,9,11)   # odd numbers
B <- c(2,4,6,8,10,12)  # even numbers

# test to see if each of the elements of A is in B  
A %in% B
```
```{r}
A <- c(1,3,5,7,9,11)   # odd numbers
B <- c(2,4,6,8,1,5)  # add some odd numbers in 

# test to see if each of the elements of A is in B  
A %in% B
```
```{r}
intersection <- A %in% B
intersection
```
```{r}
A[intersection]
```

```{r}
any(A %in% B)
all(A %in% B)
```
##### Exercise 1

Using the A and B vectors created above, evaluate each element in B to see if there is a match in A

```{r}
B %in% A
```
Subset the B vector to only return those values that are also in A.
```{r}
B[B %in% A]
```

```{r}
A <- c(10,20,30,40,50)
B <- c(50,40,30,20,10)  # same numbers but backwards 

# test to see if each element of A is in B
A %in% B

# test to see if each element of A is in the same position in B
A == B

# use all() to check if they are a perfect match
all(A == B)
```

```{r}
x <- rownames(metadata)
y <- colnames(rpkm_data)
```
```{r}
all(x %in% y)
```

```{r}
all(rownames(metadata) %in% colnames(rpkm_data))
```
```{r}
x == y
all(x == y)
```
##### Exercise 2
We have a list of 6 marker genes that we are very interested in. Our goal is to extract count data for these genes using the %in% operator from the rpkm_data data frame, instead of scrolling through rpkm_data and finding them manually.

First, let’s create a vector called important_genes with the Ensembl IDs of the 6 genes we are interested in:

```{r}
important_genes <- c("ENSMUSG00000083700", "ENSMUSG00000080990", "ENSMUSG00000065619", "ENSMUSG00000047945", "ENSMUSG00000081010", "ENSMUSG00000030970")
```
1. Use the %in% operator to determine if all of these genes are present in the row names of the rpkm_data data frame.

```{r}
important_genes %in% rownames(rpkm_data)
```
2. Extract the rows from rpkm_data that correspond to these 6 genes using [] and the %in% operator. Double check the row names to ensure that you are extracting the correct rows.

```{r}
rownames(rpkm_data)[which(rownames(rpkm_data) %in% important_genes)]
```

3. Bonus question: Extract the rows from rpkm_data that correspond to these 6 genes using [], but without using the %in% operator.

```{r}
m <- match(important_genes,rownames(rpkm_data))
rownames(rpkm_data)[m]
```

##### 09 reordering to match datasets

```{r}
teaching_team <- c("Jihe", "Mary", "Meeta", "Radhika", "Will", "Emma")
```

```{r}
# Extracting values from a vector
teaching_team[c(2, 4)] 
```

```{r}
# Extracting all values and reordering them
teaching_team[c(5, 4, 6, 2, 1, 3)]
# Saving the results to a variable
reorder_teach <- teaching_team[c(5, 4, 6, 2, 1, 3)] 
```
##### Exercise

Now that we know how to reorder using indices, let’s try to use it to reorder the contents of one vector to match the contents of another. Let’s create the vectors first and second as detailed below:
```{r}
first <- c("A","B","C","D","E")
second <- c("B","D","E","A","C")  # same letters but different order
```
How would you reorder the second vector to match first?
```{r}
second[c(4,1,5,2,3)]
```

The match function

```{r}
# Saving indices for how to reorder `second` to match `first`
reorder_idx <- match(first,second) 
```

```{r}
# Reordering the second vector to match the order of the first vector
second[reorder_idx]
```
```{r}
# Reordering and saving the output to a variable
second_reordered <- second[reorder_idx]  
```
```{r}
first <- c("A","B","C","D","E")
second <- c("D","B","A")  # remove values
```

```{r}
match(first,second)
```

```{r}
second[match(first, second)]
```

```{r}
# Check row names of the metadata
rownames(metadata)

# Check the column names of the counts data
colnames(rpkm_data)
```

```{r}
genomic_idx <- match(rownames(metadata), colnames(rpkm_data))
genomic_idx
```

```{r}
# Reorder the counts data frame to have the sample names in the same order as the metadata data frame
rpkm_ordered  <- rpkm_data[ , genomic_idx]
```

```{r}
# View the reordered counts
View(rpkm_ordered)
```

```{r}
all(rownames(metadata) == colnames(rpkm_ordered))
```
##### Exercises

After talking with your collaborator, it becomes clear that sample2 and sample9 were actually from a different mouse background than the other samples and should not be part of our analysis. Create a new variable called subset_rpkm that has these columns removed from the rpkm_ordered data frame.

```{r}
subset_rpkm <- rpkm_ordered[,-c(2,9)]
```
Use the match() function to subset the metadata data frame so that the row names of the metadata data frame match the column names of the subset_rpkm data frame.

```{r}
m <- match(colnames(subset_rpkm), rownames(metadata))
metadata[m,]
```

##### 10 Setting up to plot

```{r}
mean(rpkm_ordered$sample1)
```


```{r}

# BiocManager::install(purrr) #install purrr if you need to
library(purrr)  # Load the purrr

samplemeans <- map_dbl(rpkm_ordered, mean) 
```

```{r}
# Named vectors have a name assigned to each element instead of just referring to them as indices ([1], [2] and so on)
samplemeans

# Check length of the vector before adding it to the data frame
length(samplemeans)
```

```{r}
# Create a numeric vector with ages. Note that there are 12 elements here
age_in_days <- c(40, 32, 38, 35, 41, 32, 34, 26, 28, 28, 30, 32)      
```
```{r}
# Add the new vector as the last column to the new_metadata dataframe
new_metadata <- data.frame(metadata, samplemeans, age_in_days) 

# Take a look at the new_metadata object
View(new_metadata)
```

# 11 ggplot2

```{r}
## load the new_metadata data frame into your environment from a .RData object
load("data/new_metadata.RData")
```
```{r}
# this data frame should have 12 rows and 5 columns
View(new_metadata)
```
```{r}
library(ggplot2)
```

```{r}
ggplot(new_metadata) # what happens? 
```

```{r, eval=FALSE}
ggplot(new_metadata) +
  geom_point() # note what happens here
```

```{r}
ggplot(new_metadata) +
     geom_point(aes(x = age_in_days, y= samplemeans))
```

```{r}
ggplot(new_metadata) +
  geom_point(aes(x = age_in_days, y= samplemeans, color = genotype)) 
```

```{r}
ggplot(new_metadata) +
  geom_point(aes(x = age_in_days, y= samplemeans, color = genotype,
            shape=celltype)) 
```

```{r}
ggplot(new_metadata) +
  geom_point(aes(x = age_in_days, y= samplemeans, color = genotype,
            shape=celltype), size=2.25) 
```

```{r}
ggplot(new_metadata) +
  geom_point(aes(x = age_in_days, y= samplemeans, color = genotype,
            shape=celltype), size=3.0) +
  theme_bw()
```

```{r}
ggplot(new_metadata) +
  geom_point(aes(x = age_in_days, y= samplemeans, color = genotype,
            shape=celltype), size=2.25) +
  theme_bw() +
  theme(axis.title = element_text(size=rel(1.5)))       
```

##### Exercise

1. The current axis label text defaults to what we gave as input to geom_point (i.e the column headers). We can change this by adding additional layers called xlab() and ylab() for the x- and y-axis, respectively. Add these layers to the current plot such that the x-axis is labeled “Age (days)” and the y-axis is labeled “Mean expression”.
2. Use the ggtitle layer to add a plot title of your choice.
3. Add the following new layer to the code chunk theme(plot.title=element_text(hjust=0.5))

```{r}
ggplot(new_metadata) +
  geom_point(aes(x = age_in_days, y= samplemeans, color = genotype,
            shape=celltype), size=2.25) +
  theme_bw() +
  theme(axis.title = element_text(size=rel(1.5))) + 
  xlab("Age (days)") + ylab("Mean expression") +
  ggtitle("Mean vs Age") +
  theme(plot.title=element_text(hjust=0.5))
```
What does it change?
Ans: axes labels, title, position of title
How many theme() layers can be added to a ggplot code chunk, in your estimation?
Ans: there is no limit

##### 12 Boxplot exercise

Generate a boxplot using the data in the new_metadata dataframe. Create a ggplot2 code chunk with the following instructions:

1. Use the geom_boxplot() layer to plot the differences in sample means between the Wt and KO genotypes.

2, Use the fill aesthetic to look at differences in sample means between the celltypes within each genotype.

3. Add a title to your plot.

4. Add labels, ‘Genotype’ for the x-axis and ‘Mean expression’ for the y-axis.

5. Make the following theme() changes:
  a. Use the theme_bw() function to make the background white.
  b. Change the size of your axes labels to 1.25x larger than the default.
  c. Change the size of your plot title to 1.5x larger than default.
  d. Center the plot title.
  
```{r}
ggplot(new_metadata) +
  geom_boxplot(aes(x = genotype, y= samplemeans,
            fill=celltype)) +
  theme_bw() +
  theme(axis.title = element_text(size=rel(1.5))) + 
  xlab("Genotype") + ylab("Mean expression") +
  ggtitle("Mean vs Genotype") +
  theme(plot.title=element_text(hjust=0.5, size = rel(1.25)))
```

##### 13 Exporting data and plots

```{r}
# Save a data frame to file
write.csv(sub_meta, file="data/subset_meta.csv")
```

```{r}
# Save a vector to file
write(glengths, file="data/genome_lengths.txt")
```
Note, the ncolumns argument that it defaults to five columns unless specified, so to get a single column:

```{r}
# Save a vector to file as a single column
write(glengths, file="data/genome_lengths.txt", ncolumns = 1)
```
Exporting figures to file:

```{r}
## Open device for writing
pdf("figures/scatterplot.pdf")
```
```{r}
## Make a plot which will be written to the open device, in this case the temp file created by pdf()/png()
ggplot(new_metadata) +
  geom_point(aes(x = age_in_days, y= samplemeans, color = genotype,
            shape=celltype), size=rel(3.0)) 
```

```{r}
## Closing the device is essential to save the temporary file created by pdf()/png()
dev.off()
```

##### 14 Finding help

##### 15 Tidyverse

```{r}
# If tidyverse is not already installed, uncomment the following line of code
# BiocManager::install(tidyverse)

library(tidyverse)
```

Pipes: The pipe allows the output of a previous command to be used as input to another command instead of using nested functions.

NOTE: Shortcut to write the pipe is shift + command + M
```{r}
## A single command
sqrt(83)

## Base R method of running more than one command
round(sqrt(83), digits = 2)

## Running more than one command with piping
sqrt(83) %>% round(digits = 2)
```
##### Exercise
1. Create a vector of random numbers using the code below:

```{r}
random_numbers <- c(81, 90, 65, 43, 71, 29)
```

2. Use the pipe (%>%) to perform two steps in a single line:

    a. Take the mean of random_numbers using the mean() function.
    b. Round the output to three digits using the round() function.
    
```{r}
random_numbers %>% mean %>% round(digits = 3)
```

Tibbles

```{r}
# Read in the functional analysis results
functional_GO_results <- read_delim(file = "data/gprofiler_results_Mov10oe.tsv", delim = "\t" )

# Take a look at the results
functional_GO_results
```

```{r}
# Return only GO biological processes
bp_oe <- functional_GO_results %>%
  filter(domain == "BP")
  
View(bp_oe)
```

##### Exercise

We would like to perform an additional round of filtering to only keep the most specific GO terms.

1. For bp_oe, use the filter() function to only keep those rows where the relative.depth is greater than 4.
2. Save output to overwrite our bp_oe variable.

```{r}
bp_oe <- bp_oe %>% filter(relative.depth > 4)
```
```{r}
# Selecting columns to keep for visualization
names(bp_oe)
bp_oe <- bp_oe %>%
  select(term.id, term.name, p.value, query.size, term.size, overlap.size, intersection)

View(bp_oe)
dim(bp_oe)
```
The select() function also allows for negative selection. So we could have alternately removed columns with negative selection. Note that we need to put the column names inside of the combine (c()) function with a - preceding it for this functionality.

```{r, eval=FALSE}
# DO NOT RUN
# Selecting columns to remove
bp_oe <- bp_oe %>%
    select(-c(query.number, significant, recall, precision, subgraph.number, relative.depth, domain))
```

Let’s sort the rows by adjusted p-value with the arrange() function.

```{r}
# Order by adjusted p-value ascending
bp_oe <- bp_oe %>%
  arrange(p.value)
```
NOTE1: If you wanted to arrange in descending order, then you could have run the following instead:

```{r, eval=FALSE}
# DO NOT RUN
# Order by adjusted p-value descending
bp_oe <- bp_oe %>%
  arrange(desc(p.value))
```
Let’s rename the term.id and term.name columns.

```{r}
# Provide better names for columns
bp_oe <- bp_oe %>% 
  dplyr::rename(GO_id = term.id, 
                GO_term = term.name)
```
##### Exercise

Rename the intersection column to genes to reflect the fact that these are the DE genes associated with the GO process.

```{r}
bp_oe <- bp_oe %>% 
  dplyr::rename(genes = intersection)
```

Create additional metrics for plotting (e.g. gene ratios)

```{r}
# Create gene ratio column based on other columns in dataset
bp_oe <- bp_oe %>%
  mutate(gene_ratio = overlap.size / query.size)
```

##### Exercise

Create a column in bp_oe called term_percent to determine the percent of DE genes associated with the GO term relative to the total number of genes associated with the GO term (overlap.size / term.size)

```{r}
bp_oe <- bp_oe %>%
  mutate(term_percent = overlap.size / term.size)
```
Use ggplot to plot the first 30 significant GO terms vs gene_ratio. Color the points by p.value.

```{r}
sub = bp_oe[1:30,]
ggplot(sub,aes(x = gene_ratio,y = GO_term, color = p.value)) + geom_point()
```

